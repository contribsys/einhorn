#!/usr/bin/env ruby
require 'logger'
require 'optparse'

require 'readline'
require 'shellwords'

require 'rubygems'
require 'einhorn'

module Einhorn
  class EinhornSH
    def initialize(path_to_socket)
      @path_to_socket = path_to_socket
      reconnect
    end

    def run
      emit("Enter 'help' if you're not sure what to do.")
      emit
      emit('Type "quit" or "exit" to quit at any time')

      while line = Readline.readline('> ', true)
        begin
          run_commandline(line)
        rescue Errno::EPIPE => e
          emit("einhornsh: Error communicating with Einhorn: #{e} (#{e.class})")
          emit("einhornsh: Attempting to reconnect...")
          reconnect

          retry
        end
      end
    end

    def run_commandline(line)
      command, args = parse_command(line)
      if ['quit', 'exit'].include?(command)
        emit("Goodbye!")
        return
      end

      response = @client.command({'command' => command, 'args' => args})

      if response.kind_of?(Hash)
        puts response['message']
      else
        puts "Invalid response type #{response.class}: #{response.inspect}"
      end
    end

    def parse_command(line)
      command, *args = Shellwords.shellsplit(line)
      [command, args]
    end

    def reconnect
      begin
        @client = Einhorn::Client.for_path(@path_to_socket)
      rescue Errno::ENOENT => e
        # TODO: The exit here is a biit of a layering violation.
        Einhorn::EinhornSH.emit(<<EOF, true)
Could not connect to Einhorn master process:

  #{e}

HINT: Are you sure you are running an Einhorn master?  If so, you
should pass einhornsh the cmd_name (-c argument) provided to Einhorn.
EOF
        exit(1)
      end
      ehlo if interactive?
    end

    def ehlo
      response = @client.command('command' => 'ehlo', 'user' => ENV['USER'])
      emit(response['message'])
    end

    def self.emit(message=nil, force=false)
      $stderr.puts(message || '') if interactive? || force
    end

    def self.interactive?
      $stdin.isatty
    end

    def emit(*args)
      self.class.emit(*args)
    end

    def interactive?
      self.class.interactive?
    end
  end
end

def main
  options = {}
  optparse = OptionParser.new do |opts|
    opts.banner = "Usage: #{$0} [options] [cmd_name]

Welcome to Einhornsh: the Einhorn shell.

Pass the cmd_name of the Einhorn master you are connecting to either
as a positional argument or using `-c`. If you're running your Einhorn
with a `-d`, provide the same argument here."

    opts.on('-h', '--help', 'Display this message') do
      Einhorn::EinhornSH.emit(opts, true)
      exit(1)
    end

    opts.on('-c CMD_NAME', '--command-name CMD_NAME', 'Connect to the Einhorn master with this cmd_name') do |cmd_name|
      options[:cmd_name] = cmd_name
    end

    opts.on('-d PATH', '--socket-path PATH', 'Path to the Einhorn command socket') do |path|
      options[:socket_path] = path
    end

    opts.on('-r <commandline>', '--run <commandline>', 'Run the given commandline, i.e. -r "die SIGKILL"') do |command|
      options[:commandline] = command
    end
  end
  optparse.parse!

  if ARGV.length > 1
    Einhorn::EinhornSH.emit(optparse, true)
    return 1
  end

  Signal.trap("INT") do
    Einhorn::EinhornSH.emit
    exit(0)
  end

  path_to_socket = options[:socket_path]

  unless path_to_socket
    cmd_name = options[:cmd_name] || ARGV[0]
    path_to_socket = Einhorn::Command::Interface.default_socket_path(cmd_name)
  end

  sh = Einhorn::EinhornSH.new(path_to_socket)
  if options[:commandline]
    sh.run_commandline(options[:commandline])
  else
    sh.run
  end
  return 0
end

# Would be nice if this could be loadable rather than always
# executing, but when run under gem it's a bit hard to do so.
if true # $0 == __FILE__
  ret = main
  begin
    exit(ret)
  rescue TypeError
    exit(0)
  end
end
